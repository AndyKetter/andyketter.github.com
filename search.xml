<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[hexo]]></title>
      <url>%2F2017%2F02%2F16%2Fhexo%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fetch]]></title>
      <url>%2F2017%2F02%2F15%2Ffetch%2F</url>
      <content type="text"><![CDATA[window.fetch polyfillThe fetch() function is a Promise-based mechanism for programatically makingweb requests in the browser. This project is a polyfill that implements a subsetof the standard Fetch specification, enough to make fetch a viablereplacement for most uses of XMLHttpRequest in traditional web applications. This project adheres to the Open Code of Conduct. By participating, you areexpected to uphold this code. Table of Contents Read this first Installation Usage HTML JSON Response metadata Post form Post JSON File upload Caveats Handling HTTP error statuses Sending cookies Receiving cookies Obtaining the Response URL Browser Support Read this first If you believe you found a bug with how fetch behaves in Chrome or Firefox,please avoid opening an issue in this repository. This project is apolyfill, and since Chrome and Firefox both implement the window.fetchfunction natively, no code from this project actually takes any effect inthese browsers. See Browser support for detailedinformation. If you have trouble making a request to another domain (a differentsubdomain or port number also constitutes as another domain), pleasefamiliarize yourself with all the intricacies and limitations of CORSrequests. Because CORS requires participation of the server by implementingspecific HTTP response headers, it is often nontrivial to set up or debug.CORS is exclusively handled by the browser’s internal mechanisms which thispolyfill cannot influence. If you have trouble maintaining the user’s session or CSRF protectionthrough fetch requests, please ensure that you’ve read and understood theSending cookies section. If this polyfill doesn’t work under Node.js environment, that is expected,because this project is meant for web browsers only. You should ensure that yourapplication doesn’t try to package and run this on the server. If you have an idea for a new feature of fetch, please understand that weare only ever going to add features and APIs that are a part of theFetch specification. You should submit your feature requests to therepository of the specificationitself, rather than this repository. Installation npm install whatwg-fetch --save; or bower install fetch. You will also need a Promise polyfill for older browsers.We recommend taylorhakes/promise-polyfillfor its small size and Promises/A+ compatibility. For use with webpack, add this package in the entry configuration optionbefore your application entry point: 1entry: ['whatwg-fetch', ...] For Babel and ES2015+, make sure to import the file: 1import 'whatwg-fetch' UsageFor a more comprehensive API reference that this polyfill supports, refer tohttps://github.github.io/fetch/. HTML123456fetch('/users.html') .then(function(response) &#123; return response.text() &#125;).then(function(body) &#123; document.body.innerHTML = body &#125;) JSON12345678fetch('/users.json') .then(function(response) &#123; return response.json() &#125;).then(function(json) &#123; console.log('parsed json', json) &#125;).catch(function(ex) &#123; console.log('parsing failed', ex) &#125;) Response metadata123456fetch('/users.json').then(function(response) &#123; console.log(response.headers.get('Content-Type')) console.log(response.headers.get('Date')) console.log(response.status) console.log(response.statusText)&#125;) Post form123456var form = document.querySelector('form')fetch('/users', &#123; method: 'POST', body: new FormData(form)&#125;) Post JSON12345678910fetch('/users', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; name: 'Hubot', login: 'hubot', &#125;)&#125;) File upload12345678910var input = document.querySelector('input[type="file"]')var data = new FormData()data.append('file', input.files[0])data.append('user', 'hubot')fetch('/avatars', &#123; method: 'POST', body: data&#125;) CaveatsThe fetch specification differs from jQuery.ajax() in mainly two ways thatbear keeping in mind: The Promise returned from fetch() won’t reject on HTTP error statuseven if the response is a HTTP 404 or 500. Instead, it will resolve normally,and it will only reject on network failure, or if anything prevented therequest from completing. By default, fetch won’t send or receive any cookies from the server,resulting in unauthenticated requests if the site relies on maintaining a usersession. See Sending cookies for how to opt into cookiehandling. Handling HTTP error statusesTo have fetch Promise reject on HTTP error statuses, i.e. on any non-2xxstatus, define a custom response handler: 12345678910111213141516171819202122function checkStatus(response) &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return response &#125; else &#123; var error = new Error(response.statusText) error.response = response throw error &#125;&#125;function parseJSON(response) &#123; return response.json()&#125;fetch('/users') .then(checkStatus) .then(parseJSON) .then(function(data) &#123; console.log('request succeeded with JSON response', data) &#125;).catch(function(error) &#123; console.log('request failed', error) &#125;) Sending cookiesTo automatically send cookies for the current domain, the credentials optionmust be provided: 123fetch('/users', &#123; credentials: 'same-origin'&#125;) The “same-origin” value makes fetch behave similarly to XMLHttpRequest withregards to cookies. Otherwise, cookies won’t get sent, resulting in theserequests not preserving the authentication session. For CORS requests, use the “include” value to allow sending credentials toother domains: 123fetch('https://example.com:1234/users', &#123; credentials: 'include'&#125;) Receiving cookiesLike with XMLHttpRequest, the Set-Cookie response header returned from theserver is a forbidden header name and therefore can’t be programaticallyread with response.headers.get(). Instead, it’s the browser’s responsibilityto handle new cookies being set (if applicable to the current URL). Unless theyare HTTP-only, new cookies will be available through document.cookie. Bear in mind that the default behavior of fetch is to ignore the Set-Cookieheader completely. To opt into accepting cookies from the server, you must usethe credentials option. Obtaining the Response URLDue to limitations of XMLHttpRequest, the response.url value might not bereliable after HTTP redirects on older browsers. The solution is to configure the server to set the response HTTP headerX-Request-URL to the current URL after any redirect that might have happened.It should be safe to set it unconditionally. 12# Ruby on Rails controller exampleresponse.headers['X-Request-URL'] = request.url This server workaround is necessary if you need reliable response.url inFirefox &lt; 32, Chrome &lt; 37, Safari, or IE. Browser Support Chrome Firefox Safari 6.1+ Internet Explorer 10+ Note: modern browsers such as Chrome, Firefox, and Microsoft Edge contain nativeimplementations of window.fetch, therefore the code from this polyfill doesn’thave any effect on those browsers. If you believe you’ve encountered an errorwith how window.fetch is implemented in any of these browsers, you should filean issue with that browser vendor instead of this project. &quot;Cross-origin resource sharing&quot; &quot;Cross-site request forgery&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react]]></title>
      <url>%2F2017%2F02%2F15%2Freact%2F</url>
      <content type="text"><![CDATA[This is a collection of simple demos of React.js. These demos are purposely written in a simple and clear style. You will find no difficulty in following them to learn the powerful library. Related Projects Flux Demo Webpack Demos React Router Tutorial CSS Modules Demos React Testing Demo A boilerplate for React-Babel-Webpack project How to useFirst copy the repo into your disk. 1$ git clone git@github.com:ruanyf/react-demos.git Then play with the source files under the repo’s demo* directories. HTML Template12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="../build/react.js"&gt;&lt;/script&gt; &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Index Render JSX Use JavaScript in JSX Use array in JSX Define a component this.props.children PropTypes Finding a DOM node this.state Form Component Lifecycle Ajax Display value from a Promise Server-side rendering Demo01: Render JSXdemo / source The template syntax in React is called JSX. It is allowed in JSX to put HTML tags directly into JavaScript codes. ReactDOM.render() is the method which translates JSX into HTML, and renders it into the specified DOM node. 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); Attention, you have to use &lt;script type=&quot;text/babel&quot;&gt; to indicate JSX codes, and include browser.min.js, which is a browser version of Babel and could be get inside a babel-core@5 npm release, to actually perform the transformation in the browser. Before v0.14, React use JSTransform.js to translate &lt;script type=&quot;text/jsx&quot;&gt;. It has been deprecated (more info). Demo02: Use JavaScript in JSXdemo / source You could also use JavaScript in JSX. It takes angle brackets (&lt;) as the beginning of HTML syntax, and curly brackets ({) as the beginning of JavaScript syntax. 123456789101112var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')); Demo03: Use array in JSXdemo / source If a JavaScript variable is an array, JSX will implicitly concat all members of the array. 12345678var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); Demo04: Define a componentdemo / source React.createClass() creates a component class, which implements a render method to return an component instance of the class. You don’t need to call new on the class in order to get an instance, just use it as a normal HTML tag. 12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name="John" /&gt;, document.getElementById('example')); Components would have attributes, and you can use this.props.[attribute] to access them, just like this.props.name of &lt;HelloMessage name=&quot;John&quot; /&gt; is John. Please remember the first letter of the component’s name must be capitalized, otherwise React will throw an error. For instance, HelloMessage as a component’s name is OK, but helloMessage is not allowed. And a React component should only have one top child node. 1234567891011121314151617181920// wrongvar HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt; Hello &#123;this.props.name&#125; &lt;/h1&gt;&lt;p&gt; some text &lt;/p&gt;; &#125;&#125;);// correctvar HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt; &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt;; &#125;&#125;); Demo05: this.props.childrendemo / source React uses this.props.children to access a component’s children nodes. 123456789101112131415161718192021var NotesList = React.createClass(&#123; render: function() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example')); Please be mindful that the value of this.props.children has three possibilities. If the component has no children node, the value is undefined; If single children node, an object; If multiple children nodes, an array. You should be careful to handle it. React gave us an utility React.Children for dealing with the this.props.children‘s opaque data structure. You could use React.Children.map to iterate this.props.children without worring its data type being undefined or object. Check official document for more methods React.Children offers. Demo06: PropTypesdemo / source Components have many specific attributes which are called ”props” in React and can be of any type. Sometimes you need a way to validate these props. You don’t want users have the freedom to input anything into your components. React has a solution for this and it’s called PropTypes. 123456789var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;); The above component of MyTitle has a props of title. PropTypes tells React that the title is required and its value should be a string. Now we give Title a number value. 123456var data = 123;ReactDOM.render( &lt;MyTitle title=&#123;data&#125; /&gt;, document.getElementById('example')); It means the props doesn’t pass the validation, and the console will show you an error message. 1Warning: Failed propType: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`. Visit official doc for more PropTypes options. P.S. If you want to give the props a default value, use getDefaultProps(). 12345678910111213141516var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : 'Hello World' &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle /&gt;, document.getElementById('example')); Demo07: Finding a DOM nodedemo / source Sometimes you need to reference a DOM node in a component. React gives you the ref attribute to find it. 123456789101112131415161718var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); The desired DOM node should have a ref attribute, and this.refs.[refName] would return the corresponding DOM node. Please be mindful that you could do that only after this component has been mounted into the DOM, otherwise you get null. Demo08: this.statedemo / source React thinks of component as state machines, and uses this.state to hold component’s state, getInitialState() to initialize this.state(invoked before a component is mounted), this.setState() to update this.state and re-render the component. 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'haven\'t liked'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); You could use component attributes to register event handlers, just like onClick, onKeyDown, onCopy, etc. Official Document has all supported events. Demo09: Formdemo / source According to React’s design philosophy, this.state describes the state of component and is mutated via user interactions, and this.props describes the properties of component and is stable and immutable. Since that, the value attribute of Form components, such as &lt;input&gt;, &lt;textarea&gt;, and &lt;option&gt;, is unaffected by any user input. If you wanted to access or update the value in response to user input, you could use the onChange event. 12345678910111213141516171819var Input = React.createClass(&#123; getInitialState: function() &#123; return &#123;value: 'Hello!'&#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;Input/&gt;, document.getElementById('example')); More information on official document. Demo10: Component Lifecycledemo / source Components have three main parts of their lifecycle: Mounting(being inserted into the DOM), Updating(being re-rendered) and Unmounting(being removed from the DOM). React provides hooks into these lifecycle part. will methods are called right before something happens, and did methods which are called right after something happens. 123456789101112131415161718192021222324252627282930313233var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1.0 &#125;; &#125;, componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;Hello name="world"/&gt;, document.getElementById('example')); The following is a whole list of lifecycle methods. componentWillMount(): Fired once, before initial rendering occurs. Good place to wire-up message listeners. this.setState doesn’t work here. componentDidMount(): Fired once, after initial rendering occurs. Can use this.getDOMNode(). componentWillUpdate(object nextProps, object nextState): Fired after the component’s updates are made to the DOM. Can use this.getDOMNode() for updates. componentDidUpdate(object prevProps, object prevState): Invoked immediately after the component’s updates are flushed to the DOM. This method is not called for the initial render. Use this as an opportunity to operate on the DOM when the component has been updated. componentWillUnmount(): Fired immediately before a component is unmounted from the DOM. Good place to remove message listeners or general clean up. componentWillReceiveProps(object nextProps): Fired when a component is receiving new props. You might want to this.setState depending on the props. shouldComponentUpdate(object nextProps, object nextState): Fired before rendering when new props or state are received. return false if you know an update isn’t needed. Demo11: Ajaxdemo / source How to get the data of a component from a server or an API provider? The answer is using Ajax to fetch data in the event handler of componentDidMount. When the server response arrives, store the data with this.setState() to trigger a re-render of your UI. 12345678910111213141516171819202122232425262728293031323334var UserGist = React.createClass(&#123; getInitialState: function() &#123; return &#123; username: '', lastGistUrl: '' &#125;; &#125;, componentDidMount: function() &#123; $.get(this.props.source, function(result) &#123; var lastGist = result[0]; if (this.isMounted()) &#123; this.setState(&#123; username: lastGist.owner.login, lastGistUrl: lastGist.html_url &#125;); &#125; &#125;.bind(this)); &#125;, render: function() &#123; return ( &lt;div&gt; &#123;this.state.username&#125;'s last gist is &lt;a href=&#123;this.state.lastGistUrl&#125;&gt;here&lt;/a&gt;. &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;UserGist source="https://api.github.com/users/octocat/gists" /&gt;, document.getElementById('example')); Demo12: Display value from a Promisedemo / source This demo is inspired by Nat Pryce’s article “Higher Order React Components”. If a React component’s data is received asynchronously, we can use a Promise object as the component’s property also, just as the following. 123456ReactDOM.render( &lt;RepoList promise=&#123;$.getJSON('https://api.github.com/search/repositories?q=javascript&amp;sort=stars')&#125; /&gt;, document.getElementById('example')); The above code takes data from Github’s API, and the RepoList component gets a Promise object as its property. Now, while the promise is pending, the component displays a loading indicator. When the promise is resolved successfully, the component displays a list of repository information. If the promise is rejected, the component displays an error message. 123456789101112131415161718192021222324252627282930313233343536var RepoList = React.createClass(&#123; getInitialState: function() &#123; return &#123; loading: true, error: null, data: null&#125;; &#125;, componentDidMount() &#123; this.props.promise.then( value =&gt; this.setState(&#123;loading: false, data: value&#125;), error =&gt; this.setState(&#123;loading: false, error: error&#125;)); &#125;, render: function() &#123; if (this.state.loading) &#123; return &lt;span&gt;Loading...&lt;/span&gt;; &#125; else if (this.state.error !== null) &#123; return &lt;span&gt;Error: &#123;this.state.error.message&#125;&lt;/span&gt;; &#125; else &#123; var repos = this.state.data.items; var repoList = repos.map(function (repo) &#123; return ( &lt;li&gt; &lt;a href=&#123;repo.html_url&#125;&gt;&#123;repo.name&#125;&lt;/a&gt; (&#123;repo.stargazers_count&#125; stars) &lt;br/&gt; &#123;repo.description&#125; &lt;/li&gt; ); &#125;); return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;&#123;repoList&#125;&lt;/ol&gt; &lt;/main&gt; ); &#125; &#125;&#125;); Demo13: Server-side renderingsource This demo is copied from github.com/mhart/react-server-example, but I rewrote it with JSX syntax. 12345678# install the dependencies in demo13 directory$ npm install# translate all jsx file in src subdirectory to js file$ npm run build# launch http server$ node server.js ExtrasPrecompiling JSXAll above demos don’t use JSX compilation for clarity. In production environment, ensure to precompile JSX files before putting them online. First, install the command-line tools Babel. 1$ npm install -g babel Then precompile your JSX files(.jsx) into JavaScript(.js). Compiling the entire src directory and output it to the build directory, you may use the option --out-dir or -d. 1$ babel src --out-dir build Put the compiled JS files into HTML. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src="build/react.js"&gt;&lt;/script&gt; &lt;script src="build/react-dom.js"&gt;&lt;/script&gt; &lt;!-- No need for Browser.js! --&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script src="build/helloworld.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Useful links React’s official site React’s official examples React (Virtual) DOM Terminology, by Sebastian Markbåge The React Quick Start Guide, by Jack Callister Learning React.js: Getting Started and Concepts, by Ken Wheeler Getting started with React, by Ryan Clark React JS Tutorial and Guide to the Gotchas, by Justin Deal React Primer, by Binary Muse jQuery versus React.js thinking, by zigomir LicenseBSD licensed]]></content>
    </entry>

    
  
  
</search>
